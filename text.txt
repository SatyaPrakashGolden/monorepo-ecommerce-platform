// schemas/category.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type CategoryDocument = Category & Document;

@Schema({ timestamps: true })
export class Category {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true, unique: true })
  slug: string;

  @Prop()
  description: string;

  @Prop()
  image: string;

  @Prop({ type: Types.ObjectId, ref: 'Category' })
  parentCategory: Types.ObjectId;

  @Prop({ default: 0 })
  level: number; // 0 for main category, 1 for subcategory, etc.

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: 0 })
  sortOrder: number;

  @Prop()
  metaTitle: string;

  @Prop()
  metaDescription: string;

  @Prop([String])
  metaKeywords: string[];
}

export const CategorySchema = SchemaFactory.createForClass(Category);

// schemas/brand.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type BrandDocument = Brand & Document;

@Schema({ timestamps: true })
export class Brand {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true, unique: true })
  slug: string;

  @Prop()
  description: string;

  @Prop()
  logo: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop()
  website: string;

  @Prop()
  metaTitle: string;

  @Prop()
  metaDescription: string;
}

export const BrandSchema = SchemaFactory.createForClass(Brand);

// schemas/attribute.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type AttributeDocument = Attribute & Document;

export enum AttributeType {
  COLOR = 'color',
  SIZE = 'size',
  MATERIAL = 'material',
  PATTERN = 'pattern',
  SLEEVE_TYPE = 'sleeve_type',
  COLLAR_TYPE = 'collar_type',
  FIT = 'fit',
  OCCASION = 'occasion',
  SEASON = 'season'
}

@Schema({ timestamps: true })
export class Attribute {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true, enum: AttributeType })
  type: AttributeType;

  @Prop({ required: true })
  value: string;

  @Prop()
  colorCode: string; // For color attributes

  @Prop()
  image: string; // For visual attributes

  @Prop({ default: 0 })
  sortOrder: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const AttributeSchema = SchemaFactory.createForClass(Attribute);

// schemas/product.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type ProductDocument = Product & Document;

export enum ProductStatus {
  DRAFT = 'draft',
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  OUT_OF_STOCK = 'out_of_stock'
}

export enum Gender {
  MEN = 'men',
  WOMEN = 'women',
  UNISEX = 'unisex',
  KIDS = 'kids'
}

@Schema({ timestamps: true })
export class Product {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true, unique: true })
  slug: string;

  @Prop({ required: true })
  description: string;

  @Prop()
  shortDescription: string;

  @Prop({ required: true })
  sku: string;

  @Prop({ type: Types.ObjectId, ref: 'Brand', required: true })
  brand: Types.ObjectId;

  @Prop({ type: [{ type: Types.ObjectId, ref: 'Category' }], required: true })
  categories: Types.ObjectId[];

  @Prop({ required: true, enum: Gender })
  gender: Gender;

  @Prop({ required: true, enum: ProductStatus, default: ProductStatus.DRAFT })
  status: ProductStatus;

  @Prop({ required: true })
  basePrice: number;

  @Prop()
  discountPrice: number;

  @Prop({ default: 0 })
  discountPercentage: number;

  @Prop([String])
  images: string[];

  @Prop([String])
  tags: string[];

  @Prop({ type: Map, of: String })
  specifications: Map<string, string>;

  @Prop()
  material: string;

  @Prop()
  careInstructions: string;

  @Prop()
  origin: string;

  @Prop({ default: 0 })
  weight: number; // in grams

  @Prop({ type: Object })
  dimensions: {
    length: number;
    width: number;
    height: number;
  };

  @Prop({ default: 0 })
  totalStock: number;

  @Prop({ default: 0 })
  soldCount: number;

  @Prop({ default: 0 })
  viewCount: number;

  @Prop({ default: 0 })
  wishlistCount: number;

  @Prop({ default: 0 })
  rating: number;

  @Prop({ default: 0 })
  reviewCount: number;

  @Prop({ default: true })
  isReturnable: boolean;

  @Prop({ default: 7 })
  returnDays: number;

  @Prop({ default: false })
  isFeatured: boolean;

  @Prop({ default: false })
  isNewArrival: boolean;

  @Prop({ default: false })
  isBestSeller: boolean;

  @Prop()
  metaTitle: string;

  @Prop()
  metaDescription: string;

  @Prop([String])
  metaKeywords: string[];

  @Prop({ type: Date })
  launchDate: Date;

  @Prop({ type: Date })
  discontinueDate: Date;
}

export const ProductSchema = SchemaFactory.createForClass(Product);

// schemas/product-variant.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type ProductVariantDocument = ProductVariant & Document;

@Schema({ timestamps: true })
export class ProductVariant {
  @Prop({ type: Types.ObjectId, ref: 'Product', required: true })
  product: Types.ObjectId;

  @Prop({ required: true, unique: true })
  sku: string;

  @Prop({ required: true })
  name: string; // e.g., "Red - Large"

  @Prop({ type: [{ type: Types.ObjectId, ref: 'Attribute' }] })
  attributes: Types.ObjectId[];

  @Prop({ required: true })
  price: number;

  @Prop()
  discountPrice: number;

  @Prop({ default: 0 })
  stock: number;

  @Prop({ default: 0 })
  reserved: number; // for items in cart

  @Prop({ default: 0 })
  sold: number;

  @Prop([String])
  images: string[];

  @Prop({ type: Object })
  dimensions: {
    chest: number;
    waist: number;
    hip: number;
    length: number;
    shoulder: number;
    sleeve: number;
  };

  @Prop({ default: 0 })
  weight: number;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isDefault: boolean; // main variant to display

  @Prop()
  barcode: string;

  @Prop({ default: 0 })
  minOrderQuantity: number;

  @Prop({ default: 10 })
  maxOrderQuantity: number;
}

export const ProductVariantSchema = SchemaFactory.createForClass(ProductVariant);

// schemas/collection.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type CollectionDocument = Collection & Document;

export enum CollectionType {
  SEASONAL = 'seasonal',
  TRENDING = 'trending',
  OCCASION = 'occasion',
  STYLE = 'style',
  PROMOTION = 'promotion'
}

@Schema({ timestamps: true })
export class Collection {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true, unique: true })
  slug: string;

  @Prop()
  description: string;

  @Prop({ required: true, enum: CollectionType })
  type: CollectionType;

  @Prop()
  image: string;

  @Prop()
  bannerImage: string;

  @Prop({ type: [{ type: Types.ObjectId, ref: 'Product' }] })
  products: Types.ObjectId[];

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isFeatured: boolean;

  @Prop({ default: 0 })
  sortOrder: number;

  @Prop({ type: Date })
  startDate: Date;

  @Prop({ type: Date })
  endDate: Date;

  @Prop()
  metaTitle: string;

  @Prop()
  metaDescription: string;
}

export const CollectionSchema = SchemaFactory.createForClass(Collection);

// schemas/size-chart.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type SizeChartDocument = SizeChart & Document;

@Schema({ timestamps: true })
export class SizeChart {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true, enum: Gender })
  gender: Gender;

  @Prop({ type: Types.ObjectId, ref: 'Category', required: true })
  category: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Brand' })
  brand: Types.ObjectId;

  @Prop({ type: [Object], required: true })
  sizes: Array<{
    size: string;
    chest: number;
    waist: number;
    hip: number;
    length: number;
    shoulder: number;
    sleeve: number;
  }>;

  @Prop()
  image: string;

  @Prop()
  instructions: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const SizeChartSchema = SchemaFactory.createForClass(SizeChart);

// schemas/review.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type ReviewDocument = Review & Document;

export enum ReviewStatus {
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected'
}

@Schema({ timestamps: true })
export class Review {
  @Prop({ type: Types.ObjectId, ref: 'Product', required: true })
  product: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'ProductVariant' })
  variant: Types.ObjectId;

  @Prop({ required: true })
  userId: string; // Reference to user from MySQL

  @Prop({ required: true })
  userName: string;

  @Prop({ required: true, min: 1, max: 5 })
  rating: number;

  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  comment: string;

  @Prop([String])
  images: string[];

  @Prop({ required: true, enum: ReviewStatus, default: ReviewStatus.PENDING })
  status: ReviewStatus;

  @Prop({ default: 0 })
  helpfulCount: number;

  @Prop({ default: 0 })
  unhelpfulCount: number;

  @Prop({ default: false })
  isVerifiedPurchase: boolean;

  @Prop()
  orderId: string;

  @Prop({ type: Date })
  purchaseDate: Date;
}

export const ReviewSchema = SchemaFactory.createForClass(Review);

// dto/create-product.dto.ts
import { IsString, IsNotEmpty, IsArray, IsEnum, IsNumber, IsOptional, IsBoolean, IsDateString } from 'class-validator';
import { Gender, ProductStatus } from '../schemas/product.schema';

export class CreateProductDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  description: string;

  @IsString()
  @IsOptional()
  shortDescription?: string;

  @IsString()
  @IsNotEmpty()
  sku: string;

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsArray()
  @IsNotEmpty()
  categories: string[];

  @IsEnum(Gender)
  gender: Gender;

  @IsEnum(ProductStatus)
  @IsOptional()
  status?: ProductStatus;

  @IsNumber()
  basePrice: number;

  @IsNumber()
  @IsOptional()
  discountPrice?: number;

  @IsArray()
  @IsOptional()
  images?: string[];

  @IsArray()
  @IsOptional()
  tags?: string[];

  @IsString()
  @IsOptional()
  material?: string;

  @IsString()
  @IsOptional()
  careInstructions?: string;

  @IsString()
  @IsOptional()
  origin?: string;

  @IsNumber()
  @IsOptional()
  weight?: number;

  @IsBoolean()
  @IsOptional()
  isReturnable?: boolean;

  @IsNumber()
  @IsOptional()
  returnDays?: number;

  @IsBoolean()
  @IsOptional()
  isFeatured?: boolean;

  @IsBoolean()
  @IsOptional()
  isNewArrival?: boolean;

  @IsDateString()
  @IsOptional()
  launchDate?: string;
}

// dto/create-product-variant.dto.ts
import { IsString, IsNotEmpty, IsArray, IsNumber, IsOptional, IsBoolean } from 'class-validator';

export class CreateProductVariantDto {
  @IsString()
  @IsNotEmpty()
  product: string;

  @IsString()
  @IsNotEmpty()
  sku: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsArray()
  @IsOptional()
  attributes?: string[];

  @IsNumber()
  price: number;

  @IsNumber()
  @IsOptional()
  discountPrice?: number;

  @IsNumber()
  @IsOptional()
  stock?: number;

  @IsArray()
  @IsOptional()
  images?: string[];

  @IsNumber()
  @IsOptional()
  weight?: number;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;

  @IsString()
  @IsOptional()
  barcode?: string;
}

// services/catalog.service.ts
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product, ProductDocument } from '../schemas/product.schema';
import { Category, CategoryDocument } from '../schemas/category.schema';
import { ProductVariant, ProductVariantDocument } from '../schemas/product-variant.schema';
import { CreateProductDto } from '../dto/create-product.dto';
import { CreateProductVariantDto } from '../dto/create-product-variant.dto';

@Injectable()
export class CatalogService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<ProductDocument>,
    @InjectModel(Category.name) private categoryModel: Model<CategoryDocument>,
    @InjectModel(ProductVariant.name) private variantModel: Model<ProductVariantDocument>,
  ) {}

  async createProduct(createProductDto: CreateProductDto): Promise<Product> {
    const product = new this.productModel(createProductDto);
    return product.save();
  }

  async createProductVariant(createVariantDto: CreateProductVariantDto): Promise<ProductVariant> {
    const variant = new this.variantModel(createVariantDto);
    return variant.save();
  }

  async getProducts(filters: any = {}, page: number = 1, limit: number = 20) {
    const skip = (page - 1) * limit;
    
    const products = await this.productModel
      .find(filters)
      .populate('brand')
      .populate('categories')
      .skip(skip)
      .limit(limit)
      .sort({ createdAt: -1 });

    const total = await this.productModel.countDocuments(filters);
    
    return {
      products,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    };
  }

  async getProductWithVariants(slug: string) {
    const product = await this.productModel
      .findOne({ slug })
      .populate('brand')
      .populate('categories');

    if (!product) {
      throw new Error('Product not found');
    }

    const variants = await this.variantModel
      .find({ product: product._id })
      .populate('attributes');

    return {
      product,
      variants
    };
  }

  async getCategories() {
    return this.categoryModel
      .find({ isActive: true })
      .populate('parentCategory')
      .sort({ sortOrder: 1 });
  }

  async getCategoryProducts(slug: string, page: number = 1, limit: number = 20) {
    const category = await this.categoryModel.findOne({ slug });
    if (!category) {
      throw new Error('Category not found');
    }

    return this.getProducts({ categories: category._id }, page, limit);
  }

  async searchProducts(query: string, filters: any = {}, page: number = 1, limit: number = 20) {
    const searchFilters = {
      $or: [
        { name: { $regex: query, $options: 'i' } },
        { description: { $regex: query, $options: 'i' } },
        { tags: { $in: [new RegExp(query, 'i')] } }
      ],
      ...filters
    };

    return this.getProducts(searchFilters, page, limit);
  }

  async getFeaturedProducts(limit: number = 10) {
    return this.productModel
      .find({ isFeatured: true, status: 'active' })
      .populate('brand')
      .populate('categories')
      .limit(limit)
      .sort({ createdAt: -1 });
  }

  async getNewArrivals(limit: number = 10) {
    return this.productModel
      .find({ isNewArrival: true, status: 'active' })
      .populate('brand')
      .populate('categories')
      .limit(limit)
      .sort({ createdAt: -1 });
  }

  async getBestSellers(limit: number = 10) {
    return this.productModel
      .find({ isBestSeller: true, status: 'active' })
      .populate('brand')
      .populate('categories')
      .limit(limit)
      .sort({ soldCount: -1 });
  }
}

// catalog.module.ts
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatalogService } from './services/catalog.service';
import { Product, ProductSchema } from './schemas/product.schema';
import { Category, CategorySchema } from './schemas/category.schema';
import { Brand, BrandSchema } from './schemas/brand.schema';
import { Attribute, AttributeSchema } from './schemas/attribute.schema';
import { ProductVariant, ProductVariantSchema } from './schemas/product-variant.schema';
import { Collection, CollectionSchema } from './schemas/collection.schema';
import { SizeChart, SizeChartSchema } from './schemas/size-chart.schema';
import { Review, ReviewSchema } from './schemas/review.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Product.name, schema: ProductSchema },
      { name: Category.name, schema: CategorySchema },
      { name: Brand.name, schema: BrandSchema },
      { name: Attribute.name, schema: AttributeSchema },
      { name: ProductVariant.name, schema: ProductVariantSchema },
      { name: Collection.name, schema: CollectionSchema },
      { name: SizeChart.name, schema: SizeChartSchema },
      { name: Review.name, schema: ReviewSchema },
    ]),
  ],
  providers: [CatalogService],
  exports: [CatalogService],
})
export class CatalogModule {}